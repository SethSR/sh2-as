
use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Asm {
	atype: Type,
	n: u8,
	m: u8,
	d: u8,
}

impl Asm {
	pub fn none(atype: Type) -> Self {
		Self { atype, n: 0, m: 0, d: 0 }
	}

	pub fn imm8(atype: Type, d: u8) -> Self {
		Self { atype, d, n: 0, m: 0 }
	}

	pub fn imm12(atype: Type, d: u16) -> Self {
		let [n,d] = d.to_be_bytes();
		Self { atype, d,
			n: n & 0x0F,
			m: 0,
		}
	}

	pub fn reg1_imm(atype: Type, n: u8, d: u8) -> Self {
		Self { atype, n, m: 0, d }
	}

	pub fn reg2_imm(atype: Type, n: u8, m: u8, d: u8) -> Self {
		Self { atype, n, m, d }
	}

	pub fn reg1(atype: Type, n: u8) -> Self {
		Self { atype, n, m: 0, d: 0 }
	}

	pub fn reg2(atype: Type, m: u8, n: u8) -> Self {
		Self { atype, n, m, d: 0 }
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Type {
	/* Data Transfer */
	MovImm,
	MovPcRegW,
	MovPcRegL,
	MovRegReg,
	MovRegAdrB,
	MovRegAdrW,
	MovRegAdrL,
	MovAdrRegB,
	MovAdrRegW,
	MovAdrRegL,
	MovRegDecB,
	MovRegDecW,
	MovRegDecL,
	MovIncRegB,
	MovIncRegW,
	MovIncRegL,
	MovR0DspB,
	MovR0DspW,
	MovRegDspL,
	MovDspR0B,
	MovDspR0W,
	MovDspRegL,
	MovRegR0B,
	MovRegR0W,
	MovRegR0L,
	MovR0RegB,
	MovR0RegW,
	MovR0RegL,
	MovR0GbrB,
	MovR0GbrW,
	MovR0GbrL,
	MovGbrR0B,
	MovGbrR0W,
	MovGbrR0L,
	MovA,
	MovT,
	SwapB,
	SwapW,
	Xtrct,

	/* Arithmetic */
	AddRegReg,
	AddImmReg,
	AddC,
	AddV,
	CmpEqImm,
	CmpEqReg,
	CmpHs,
	CmpGe,
	CmpHi,
	CmpGt,
	CmpPl,
	CmpPz,
	CmpStr,
	Div1,
	Div0S,
	Div0U,
	DMulS,
	DMulU,
	Dt,
	ExtSB,
	ExtSW,
	ExtUB,
	ExtUW,
	MacW,
	MacL,
	Mul,
	MulS,
	MulU,
	Neg,
	NegC,
	Sub,
	SubC,
	SubV,

	/* Logic Operations */
	AndRegReg,
	AndImmR0,
	AndImmGbr,
	Not,
	OrRegReg,
	OrImmR0,
	OrImmGbr,
	Tas,
	TstRegReg,
	TstImmR0,
	TstImmGbr,
	XorRegReg,
	XorImmR0,
	XorImmGbr,

	/* Shift */
	RotL,
	RotR,
	RotCL,
	RotCR,
	ShAL,
	ShAR,
	ShLL,
	ShLR,
	ShLL2,
	ShLR2,
	ShLL8,
	ShLR8,
	ShLL16,
	ShLR16,

	/* Branch */
	Bf,
	BfS,
	Bt,
	BtS,
	Bra,
	BraF,
	Bsr,
	BsrF,
	Jmp,
	Jsr,
	Rts,

	/* System Control */
	ClrT,
	ClrMac,
	LdcRegSr,
	LdcRegGbr,
	LdcRegVbr,
	LdcIncSr,
	LdcIncGbr,
	LdcIncVbr,
	LdsRegMach,
	LdsRegMacl,
	LdsRegPr,
	LdsIncMach,
	LdsIncMacl,
	LdsIncPr,
	Nop,
	Rte,
	SetT,
	Sleep,
	StcSrReg,
	StcGbrReg,
	StcVbrReg,
	StcSrDec,
	StcGbrDec,
	StcVbrDec,
	StsMachReg,
	StsMaclReg,
	StsPrReg,
	StsMachDec,
	StsMaclDec,
	StsPrDec,
	TrapA,
}

impl fmt::Display for Asm {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let Asm { n, m, d, atype } = self;

		match atype {
			/* Data Transfer */
			Type::MovImm     => write!(f, "MOV #{},R{n}", *d as i8),
			Type::MovPcRegW  => write!(f, "MOV.W @({},PC),R{n}", *d as i16 * 2),
			Type::MovPcRegL  => write!(f, "MOV.L @({},PC),R{n}", *d as i32 * 4),
			Type::MovRegReg  => write!(f, "MOV R{m},R{n}"),
			Type::MovRegAdrB => write!(f, "MOV.B R{m},@R{n}"),
			Type::MovRegAdrW => write!(f, "MOV.W R{m},@R{n}"),
			Type::MovRegAdrL => write!(f, "MOV.L R{m},@R{n}"),
			Type::MovAdrRegB => write!(f, "MOV.B @R{m},R{n}"),
			Type::MovAdrRegW => write!(f, "MOV.W @R{m},R{n}"),
			Type::MovAdrRegL => write!(f, "MOV.L @R{m},R{n}"),
			Type::MovRegDecB => write!(f, "MOV.B R{m},@-R{n}"),
			Type::MovRegDecW => write!(f, "MOV.W R{m},@-R{n}"),
			Type::MovRegDecL => write!(f, "MOV.L R{m},@-R{n}"),
			Type::MovIncRegB => write!(f, "MOV.B @R{m}+,R{n}"),
			Type::MovIncRegW => write!(f, "MOV.W @R{m}+,R{n}"),
			Type::MovIncRegL => write!(f, "MOV.L @R{m}+,R{n}"),
			Type::MovR0DspB  => write!(f, "MOV.B R0,@({},R{n})", *d as i8),
			Type::MovR0DspW  => write!(f, "MOV.W R0,@({},R{n})", *d as i16 * 2),
			Type::MovRegDspL => write!(f, "MOV.L R{m},@({},R{n})", *d as i32 * 4),
			Type::MovDspR0B  => write!(f, "MOV.B @({},R{m}),R0", *d as i8),
			Type::MovDspR0W  => write!(f, "MOV.W @({},R{m}),R0", *d as i16 * 2),
			Type::MovDspRegL => write!(f, "MOV.L @({},R{m}),R{n}", *d as i32 * 4),
			Type::MovRegR0B  => write!(f, "MOV.B R{m},@(R0,R{n})"),
			Type::MovRegR0W  => write!(f, "MOV.W R{m},@(R0,R{n})"),
			Type::MovRegR0L  => write!(f, "MOV.L R{m},@(R0,R{n})"),
			Type::MovR0RegB  => write!(f, "MOV.B @(R0,R{m}),R{n}"),
			Type::MovR0RegW  => write!(f, "MOV.W @(R0,R{m}),R{n}"),
			Type::MovR0RegL  => write!(f, "MOV.L @(R0,R{m}),R{n}"),
			Type::MovR0GbrB  => write!(f, "MOV.B R0,@({d},GBR)"),
			Type::MovR0GbrW  => write!(f, "MOV.W R0,@({},GBR)", d * 2),
			Type::MovR0GbrL  => write!(f, "MOV.L R0,@({},GBR)", d * 4),
			Type::MovGbrR0B  => write!(f, "MOV.B @({d},GBR),R0"),
			Type::MovGbrR0W  => write!(f, "MOV.W @({},GBR),R0", d * 2),
			Type::MovGbrR0L  => write!(f, "MOV.L @({},GBR),R0", d * 4),
			Type::MovA       => write!(f, "MOVA @({},PC),R0", d * 4),
			Type::MovT       => write!(f, "MOVT R{n}"),
			Type::SwapB      => write!(f, "SWAP.B R{m},R{n}"),
			Type::SwapW      => write!(f, "SWAP.W R{m},R{n}"),
			Type::Xtrct      => write!(f, "XTRCT R{m},R{n}"),

			/* Arithmetic */
			Type::AddRegReg  => write!(f, "ADD R{m},R{n}"),
			Type::AddImmReg  => write!(f, "ADD #{d},R{n}"),
			Type::AddC       => write!(f, "ADDC R{m},R{n}"),
			Type::AddV       => write!(f, "ADDV R{m},R{n}"),
			Type::CmpEqImm   => write!(f, "CMP/EQ #{d},R0"),
			Type::CmpEqReg   => write!(f, "CMP/EQ R{m},R{n}"),
			Type::CmpHs      => write!(f, "CMP/HS R{m},R{n}"),
			Type::CmpGe      => write!(f, "CMP/GE R{m},R{n}"),
			Type::CmpHi      => write!(f, "CMP/HI R{m},R{n}"),
			Type::CmpGt      => write!(f, "CMP/GT R{m},R{n}"),
			Type::CmpPl      => write!(f, "CMP/PL R{n}"),
			Type::CmpPz      => write!(f, "CMP/PZ R{n}"),
			Type::CmpStr     => write!(f, "CMP/STR R{m},R{n}"),
			Type::Div1       => write!(f, "DIV1 R{m},R{n}"),
			Type::Div0S      => write!(f, "DIV0S R{m},R{n}"),
			Type::Div0U      => write!(f, "DIV0U"),
			Type::DMulS      => write!(f, "DMULS.L R{m},R{n}"),
			Type::DMulU      => write!(f, "DMULU.L R{m},R{n}"),
			Type::Dt         => write!(f, "DT R{n}"),
			Type::ExtSB      => write!(f, "EXTS.B R{m},R{n}"),
			Type::ExtSW      => write!(f, "EXTS.W R{m},R{n}"),
			Type::ExtUB      => write!(f, "EXTU.B R{m},R{n}"),
			Type::ExtUW      => write!(f, "EXTU.W R{m},R{n}"),
			Type::MacW       => write!(f, "MAC.W @R{m}+,@R{n}+"),
			Type::MacL       => write!(f, "MAC.L @R{m}+,@R{n}+"),
			Type::Mul        => write!(f, "MUL.L R{m},R{n}"),
			Type::MulS       => write!(f, "MULS.W R{m},R{n}"),
			Type::MulU       => write!(f, "MULU.W R{m},R{n}"),
			Type::Neg        => write!(f, "NEG R{m},R{n}"),
			Type::NegC       => write!(f, "NEGC R{m},R{n}"),
			Type::Sub        => write!(f, "SUB R{m},R{n}"),
			Type::SubC       => write!(f, "SUBC R{m},R{n}"),
			Type::SubV       => write!(f, "SUBV R{m},R{n}"),

			/* Logic Operations */
			Type::AndRegReg  => write!(f, "AND R{m},R{n}"),
			Type::AndImmR0   => write!(f, "AND #{d},R0"),
			Type::AndImmGbr  => write!(f, "AND.B #{d},@(R0,GBR)"),
			Type::Not        => write!(f, "NOT R{m},R{n}"),
			Type::OrRegReg   => write!(f, "OR R{m},R{n}"),
			Type::OrImmR0    => write!(f, "OR #{d},R0"),
			Type::OrImmGbr   => write!(f, "OR.B #{d},@(R0,GBR)"),
			Type::Tas        => write!(f, "TAS.B @R{n}"),
			Type::TstRegReg  => write!(f, "TST R{m},R{n}"),
			Type::TstImmR0   => write!(f, "TST #{d},R0"),
			Type::TstImmGbr  => write!(f, "TST.B #{d},@(R0,GBR)"),
			Type::XorRegReg  => write!(f, "XOR R{m},R{n}"),
			Type::XorImmR0   => write!(f, "XOR #{d},R0"),
			Type::XorImmGbr  => write!(f, "XOR.B #{d},@(R0,GBR)"),

			/* Shift */
			Type::RotL   => write!(f, "ROTL R{n}"),
			Type::RotR   => write!(f, "ROTR R{n}"),
			Type::RotCL  => write!(f, "ROTCL R{n}"),
			Type::RotCR  => write!(f, "ROTCR R{n}"),
			Type::ShAL   => write!(f, "SHAL R{n}"),
			Type::ShAR   => write!(f, "SHAR R{n}"),
			Type::ShLL   => write!(f, "SHLL R{n}"),
			Type::ShLR   => write!(f, "SHLR R{n}"),
			Type::ShLL2  => write!(f, "SHLL2 R{n}"),
			Type::ShLR2  => write!(f, "SHLR2 R{n}"),
			Type::ShLL8  => write!(f, "SHLL8 R{n}"),
			Type::ShLR8  => write!(f, "SHLR8 R{n}"),
			Type::ShLL16 => write!(f, "SHLL16 R{n}"),
			Type::ShLR16 => write!(f, "SHLR16 R{n}"),

			/* Branch */
			Type::Bf   => write!(f, "BF @({},PC)", d * 2),
			Type::BfS  => write!(f, "BF/S @({},PC)", d * 2),
			Type::Bt   => write!(f, "BT @({},PC)", d * 2),
			Type::BtS  => write!(f, "BT/S @({},PC)", d * 2),
			Type::Bra  => write!(f, "BRA @({},PC)", ((*n as u16) << 8 | *d as u16) * 2),
			Type::BraF => write!(f, "BRAF R{n}"),
			Type::Bsr  => write!(f, "BSR @({},PC)", ((*n as u16) << 8 | *d as u16) * 2),
			Type::BsrF => write!(f, "BSRF R{n}"),
			Type::Jmp  => write!(f, "JMP @R{n}"),
			Type::Jsr  => write!(f, "JSR @R{n}"),
			Type::Rts  => write!(f, "RTS"),

			/* System Control */
			Type::ClrT       => write!(f, "CLRT"),
			Type::ClrMac     => write!(f, "CLRMAC"),
			Type::LdcRegSr   => write!(f, "LDC R{n},SR"),
			Type::LdcRegGbr  => write!(f, "LDC R{n},GBR"),
			Type::LdcRegVbr  => write!(f, "LDC R{n},VBR"),
			Type::LdcIncSr   => write!(f, "LDC.L @R{n}+,SR"),
			Type::LdcIncGbr  => write!(f, "LDC.L @R{n}+,GBR"),
			Type::LdcIncVbr  => write!(f, "LDC.L @R{n}+,VBR"),
			Type::LdsRegMach => write!(f, "LDS R{n},MACH"),
			Type::LdsRegMacl => write!(f, "LDS R{n},MACL"),
			Type::LdsRegPr   => write!(f, "LDS R{n},PR"),
			Type::LdsIncMach => write!(f, "LDS.L @R{n}+,MACH"),
			Type::LdsIncMacl => write!(f, "LDS.L @R{n}+,MACL"),
			Type::LdsIncPr   => write!(f, "LDS.L @R{n}+,PR"),
			Type::Nop        => write!(f, "NOP"),
			Type::Rte        => write!(f, "RTE"),
			Type::SetT       => write!(f, "SETT"),
			Type::Sleep      => write!(f, "SLEEP"),
			Type::StcSrReg   => write!(f, "STC SR,R{n}"),
			Type::StcGbrReg  => write!(f, "STC GBR,R{n}"),
			Type::StcVbrReg  => write!(f, "STC VBR,R{n}"),
			Type::StcSrDec   => write!(f, "STC.L SR,@-R{n}"),
			Type::StcGbrDec  => write!(f, "STC.L GBR,@-R{n}"),
			Type::StcVbrDec  => write!(f, "STC.L VBR,@-R{n}"),
			Type::StsMachReg => write!(f, "STS MACH,R{n}"),
			Type::StsMaclReg => write!(f, "STS MACL,R{n}"),
			Type::StsPrReg   => write!(f, "STS PR,R{n}"),
			Type::StsMachDec => write!(f, "STS.L MACH,@-R{n}"),
			Type::StsMaclDec => write!(f, "STS.L MACL,@-R{n}"),
			Type::StsPrDec   => write!(f, "STS.L PR,@-R{n}"),
			Type::TrapA      => write!(f, "TRAPA #{}", *d as u16 * 4),
		}
	}
}

impl From<Asm> for [u8;2] {
	fn from(asm: Asm) -> [u8;2] {
		let Asm { d, m, n, atype } = asm;
		let m = m << 4;

		match atype {
			/* Data Transfer */
			Type::MovImm     => [ 0xE0 | n, d ],
			Type::MovPcRegW  => [ 0x90 | n, d ],
			Type::MovPcRegL  => [ 0xD0 | n, d ],
			Type::MovRegReg  => [ 0x60 | n, 0x03 | m ],
			Type::MovRegAdrB => [ 0x20 | n, m ],
			Type::MovRegAdrW => [ 0x20 | n, 0x01 | m ],
			Type::MovRegAdrL => [ 0x20 | n, 0x02 | m ],
			Type::MovAdrRegB => [ 0x60 | n, m ],
			Type::MovAdrRegW => [ 0x60 | n, 0x01 | m ],
			Type::MovAdrRegL => [ 0x60 | n, 0x02 | m ],
			Type::MovRegDecB => [ 0x20 | n, 0x04 | m ],
			Type::MovRegDecW => [ 0x20 | n, 0x05 | m ],
			Type::MovRegDecL => [ 0x20 | n, 0x06 | m ],
			Type::MovIncRegB => [ 0x60 | n, 0x04 | m ],
			Type::MovIncRegW => [ 0x60 | n, 0x05 | m ],
			Type::MovIncRegL => [ 0x60 | n, 0x06 | m ],
			Type::MovR0DspB  => [ 0x80, n << 4 | d & 0xF ],
			Type::MovR0DspW  => [ 0x81, n << 4 | d & 0xF ],
			Type::MovRegDspL => [ 0x10 | n, m | d & 0xF ],
			Type::MovDspR0B  => [ 0x84, m | d & 0xF ],
			Type::MovDspR0W  => [ 0x85, m | d & 0xF ],
			Type::MovDspRegL => [ 0x50 | n, m | d & 0xF ],
			Type::MovRegR0B  => [ n, 0x04 | m ],
			Type::MovRegR0W  => [ n, 0x05 | m ],
			Type::MovRegR0L  => [ n, 0x06 | m ],
			Type::MovR0RegB  => [ n, 0x0C | m ],
			Type::MovR0RegW  => [ n, 0x0D | m ],
			Type::MovR0RegL  => [ n, 0x0E | m ],
			Type::MovR0GbrB  => [ 0xC0, d ],
			Type::MovR0GbrW  => [ 0xC1, d ],
			Type::MovR0GbrL  => [ 0xC2, d ],
			Type::MovGbrR0B  => [ 0xC4, d ],
			Type::MovGbrR0W  => [ 0xC5, d ],
			Type::MovGbrR0L  => [ 0xC6, d ],
			Type::MovA       => [ 0xC7, d ],
			Type::MovT       => [ n, 0x29 ],
			Type::SwapB      => [ 0x60 | n, 0x08 | m ],
			Type::SwapW      => [ 0x60 | n, 0x09 | m ],
			Type::Xtrct      => [ 0x20 | n, 0x0D | m ],

			/* Arithmetic */
			Type::AddRegReg => [ 0x30 | n, 0x0C | m ],
			Type::AddImmReg => [ 0x70 | n, d ],
			Type::AddC      => [ 0x30 | n, 0x0E | m ],
			Type::AddV      => [ 0x30 | n, 0x0F | m ],
			Type::CmpEqImm  => [ 0x88, d ],
			Type::CmpEqReg  => [ 0x30 | n, m ],
			Type::CmpHs     => [ 0x30 | n, 0x02 | m ],
			Type::CmpGe     => [ 0x30 | n, 0x03 | m ],
			Type::CmpHi     => [ 0x30 | n, 0x06 | m ],
			Type::CmpGt     => [ 0x30 | n, 0x07 | m ],
			Type::CmpPl     => [ 0x40 | n, 0x15 ],
			Type::CmpPz     => [ 0x40 | n, 0x11 ],
			Type::CmpStr    => [ 0x20 | n, 0x0C | m ],
			Type::Div1      => [ 0x30 | n, 0x04 | m ],
			Type::Div0S     => [ 0x20 | n, 0x07 | m ],
			Type::Div0U     => [ 0x00, 0x19 ],
			Type::DMulS     => [ 0x30 | n, 0x0D | m ],
			Type::DMulU     => [ 0x30 | n, 0x05 | m ],
			Type::Dt        => [ 0x40 | n, 0x10 ],
			Type::ExtSB     => [ 0x60 | n, 0x0E | m ],
			Type::ExtSW     => [ 0x60 | n, 0x0F | m ],
			Type::ExtUB     => [ 0x60 | n, 0x0C | m ],
			Type::ExtUW     => [ 0x60 | n, 0x0D | m ],
			Type::MacW      => [ 0x40 | n, 0x0F | m ],
			Type::MacL      => [ n, 0x0F | m ],
			Type::Mul       => [ n, 0x07 | m ],
			Type::MulS      => [ 0x20 | n, 0x0F | m ],
			Type::MulU      => [ 0x20 | n, 0x0E | m ],
			Type::Neg       => [ 0x60 | n, 0x0B | m ],
			Type::NegC      => [ 0x60 | n, 0x0A | m ],
			Type::Sub       => [ 0x30 | n, 0x08 | m ],
			Type::SubC      => [ 0x30 | n, 0x0A | m ],
			Type::SubV      => [ 0x30 | n, 0x0B | m ],

			/* Logic Operations */
			Type::AndRegReg => [ 0x20 | n, 0x09 | m ],
			Type::AndImmR0  => [ 0xC9, d ],
			Type::AndImmGbr => [ 0xCD, d ],
			Type::Not        => [ 0x60 | n, 0x07 | m ],
			Type::OrRegReg   => [ 0x20 | n, 0x0B | m ],
			Type::OrImmR0   => [ 0xCB, d ],
			Type::OrImmGbr  => [ 0xCF, d ],
			Type::Tas       => [ 0x40 | n, 0x1B ],
			Type::TstRegReg => [ 0x20 | n, 0x08 | m ],
			Type::TstImmR0  => [ 0xC8, d ],
			Type::TstImmGbr => [ 0xCC, d ],
			Type::XorRegReg => [ 0x20 | n, 0x0A | m ],
			Type::XorImmR0  => [ 0xCA, d ],
			Type::XorImmGbr => [ 0xCE, d ],

			/* Shift */
			Type::RotL   => [ 0x40 | n, 0x04 ],
			Type::RotR   => [ 0x40 | n, 0x05 ],
			Type::RotCL  => [ 0x40 | n, 0x24 ],
			Type::RotCR  => [ 0x40 | n, 0x25 ],
			Type::ShAL   => [ 0x40 | n, 0x20 ],
			Type::ShAR   => [ 0x40 | n, 0x21 ],
			Type::ShLL   => [ 0x40 | n, 0x00 ],
			Type::ShLR   => [ 0x40 | n, 0x01 ],
			Type::ShLL2  => [ 0x40 | n, 0x08 ],
			Type::ShLR2  => [ 0x40 | n, 0x09 ],
			Type::ShLL8  => [ 0x40 | n, 0x18 ],
			Type::ShLR8  => [ 0x40 | n, 0x19 ],
			Type::ShLL16 => [ 0x40 | n, 0x28 ],
			Type::ShLR16 => [ 0x40 | n, 0x29 ],

			/* Branch */
			Type::Bf   => [ 0x8B, d ],
			Type::BfS  => [ 0x8F, d ],
			Type::Bt   => [ 0x89, d ],
			Type::BtS  => [ 0x8D, d ],
			Type::Bra  => [ 0xA0 | n, d ],
			Type::BraF => [ n, 0x23 ],
			Type::Bsr  => [ 0xB0 | n, d ],
			Type::BsrF => [ n, 0x03 ],
			Type::Jmp  => [ 0x40 | n, 0x2B ],
			Type::Jsr  => [ 0x40 | n, 0x0B ],
			Type::Rts  => [ 0x00, 0x0B ],

			/* System Control */
			Type::ClrT       => [ 0x00, 0x08 ],
			Type::ClrMac     => [ 0x00, 0x28 ],
			Type::LdcRegSr   => [ 0x40 | n, 0x0E ],
			Type::LdcRegGbr  => [ 0x40 | n, 0x1E ],
			Type::LdcRegVbr  => [ 0x40 | n, 0x2E ],
			Type::LdcIncSr   => [ 0x40 | n, 0x07 ],
			Type::LdcIncGbr  => [ 0x40 | n, 0x17 ],
			Type::LdcIncVbr  => [ 0x40 | n, 0x27 ],
			Type::LdsRegMach => [ 0x40 | n, 0x0A ],
			Type::LdsRegMacl => [ 0x40 | n, 0x1A ],
			Type::LdsRegPr   => [ 0x40 | n, 0x2A ],
			Type::LdsIncMach => [ 0x40 | n, 0x06 ],
			Type::LdsIncMacl => [ 0x40 | n, 0x16 ],
			Type::LdsIncPr   => [ 0x40 | n, 0x26 ],
			Type::Nop        => [ 0x00, 0x09 ],
			Type::Rte        => [ 0x00, 0x2B ],
			Type::SetT       => [ 0x00, 0x18 ],
			Type::Sleep      => [ 0x00, 0x1B ],
			Type::StcSrReg   => [ n, 0x02 ],
			Type::StcGbrReg  => [ n, 0x12 ],
			Type::StcVbrReg  => [ n, 0x22 ],
			Type::StcSrDec   => [ 0x40 | n, 0x03 ],
			Type::StcGbrDec  => [ 0x40 | n, 0x13 ],
			Type::StcVbrDec  => [ 0x40 | n, 0x23 ],
			Type::StsMachReg => [ n, 0x0A ],
			Type::StsMaclReg => [ n, 0x1A ],
			Type::StsPrReg   => [ n, 0x2A ],
			Type::StsMachDec => [ 0x40 | n, 0x02 ],
			Type::StsMaclDec => [ 0x40 | n, 0x12 ],
			Type::StsPrDec   => [ 0x40 | n, 0x22 ],
			Type::TrapA      => [ 0xC3, d ],
		}
	}
}

